# .tlv file generated by https://github.com/akkartik/teliva
# You may edit it if you are careful; however, you may see cryptic errors if you
# violate Teliva's assumptions.
#
# .tlv files are representations of Teliva programs. Teliva programs consist of
# sequences of definitions. Each definition is a table of key/value pairs. Keys
# and values are both strings.
#
# Lines in .tlv files always follow exactly one of the following forms:
# - comment lines at the top of the file starting with '#' at column 0
# - beginnings of definitions starting with '- ' at column 0, followed by a
#   key/value pair
# - key/value pairs consisting of '  ' at column 0, containing either a
#   spaceless value on the same line, or a multi-line value
# - multiline values indented by more than 2 spaces, starting with a '>'
#
# If these constraints are violated, Teliva may unceremoniously crash. Please
# report bugs at http://akkartik.name/contact
- __teliva_timestamp: original
  str_helpers:
    >-- some string helpers from http://lua-users.org/wiki/StringIndexing
    >
    >-- index characters using []
    >getmetatable('').__index = function(str,i)
    >  if type(i) == 'number' then
    >    return string.sub(str,i,i)
    >  else
    >    return string[i]
    >  end
    >end
    >
    >-- ranges using (), selected bytes using {}
    >getmetatable('').__call = function(str,i,j)
    >  if type(i)~='table' then
    >    return string.sub(str,i,j)
    >  else
    >    local t={}
    >    for k,v in ipairs(i) do
    >      t[k]=string.sub(str,v,v)
    >    end
    >    return table.concat(t)
    >  end
    >end
    >
    >-- iterate over an ordered sequence
    >function q(x)
    >  if type(x) == 'string' then
    >    return x:gmatch('.')
    >  else
    >    return ipairs(x)
    >  end
    >end
    >
    >-- insert within string
    >function string.insert(str1, str2, pos)
    >  return str1:sub(1,pos)..str2..str1:sub(pos+1)
    >end
    >
    >function string.remove(s, pos)
    >  return s:sub(1,pos-1)..s:sub(pos+1)
    >end
    >
    >-- TODO: backport utf-8 support from Lua 5.3
- __teliva_timestamp: original
  map:
    >-- only for arrays
    >function map(l, f)
    >  result = {}
    >  for _, x in ipairs(l) do
    >    table.insert(result, f(x))
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  reduce:
    >-- only for arrays
    >function reduce(l, f, init)
    >  result = init
    >  for _, x in ipairs(l) do
    >    result = f(result, x)
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  filter:
    >-- only for arrays
    >function filter(l, f)
    >  result = {}
    >  for _, x in ipairs(l) do
    >    if f(x) then
    >      table.insert(result, x)
    >    end
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  find_index:
    >function find_index(arr, x)
    >  for n, y in ipairs(arr) do
    >    if x == y then
    >      return n
    >    end
    >  end
    >end
- __teliva_timestamp: original
  trim:
    >function trim(s)
    >  return s:gsub('^%s*', ''):gsub('%s*$', '')
    >end
- __teliva_timestamp: original
  split:
    >function split(s, d)
    >  result = {}
    >  for match in (s..d):gmatch("(.-)"..d) do
    >    table.insert(result, match);
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  window:
    >window = curses.stdscr()
- __teliva_timestamp: original
  render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  window:attron(curses.A_BOLD)
    >  window:mvaddstr(1, 5, "example app")
    >  window:attrset(curses.A_NORMAL)
    >  for i=0,15 do
    >    window:attrset(curses.color_pair(i))
    >    window:mvaddstr(3+i, 5, "========================")
    >  end
    >  curses.refresh()
    >end
- __teliva_timestamp: original
  menu:
    >menu = {}
- __teliva_timestamp: original
  update:
    >function update(window)
    >  local key = curses.getch()
    >  -- process key here
    >end
- __teliva_timestamp: original
  init_colors:
    >function init_colors()
    >  for i=0,7 do
    >    curses.init_pair(i, i, -1)
    >  end
    >  curses.init_pair(8, 7, 0)
    >  curses.init_pair(9, 7, 1)
    >  curses.init_pair(10, 7, 2)
    >  curses.init_pair(11, 7, 3)
    >  curses.init_pair(12, 7, 4)
    >  curses.init_pair(13, 7, 5)
    >  curses.init_pair(14, 7, 6)
    >  curses.init_pair(15, -1, 15)
    >end
- main:
    >function main()
    >  init_colors()
    >
    >  while true do
    >    render(window)
    >    update(window)
    >  end
    >end
  __teliva_timestamp: original
- __teliva_timestamp:
    >Tue Dec 14 17:21:28 2021
  prose:
    >prose = ''
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  window:addstr(prose)
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:21:58 2021
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  window:addstr(prose)
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:22:02 2021
- __teliva_timestamp:
    >Tue Dec 14 17:22:05 2021
  prose:
    >prose = 'abc'
- __teliva_timestamp:
    >Tue Dec 14 17:22:08 2021
  prose:
    >prose = 'abc'
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  print(string.len(prose))
    >  window:addstr(prose)
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:22:33 2021
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  print(string.len(prose))
    >  window:addstr(prose)
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:22:39 2021
- __teliva_timestamp:
    >Tue Dec 14 17:22:44 2021
  prose:
    >prose = 'abc%def'
- __teliva_timestamp:
    >Tue Dec 14 17:22:48 2021
  prose:
    >prose = 'abc%def'
- __teliva_timestamp:
    >Tue Dec 14 17:22:53 2021
  prose:
    >prose = 'abc%def'
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n\n', string.len(toot))
    >    print(toot)
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:25:23 2021
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n\n', string.len(toot)))
    >    print(toot)
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:25:29 2021
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n\n', string.len(toot)))
    >    print(toot)
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:26:44 2021
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n\n', string.len(toot)))
    >    print(toot)
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:27:53 2021
- __teliva_timestamp:
    >Tue Dec 14 17:28:01 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- __teliva_timestamp:
    >Tue Dec 14 17:28:10 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- __teliva_timestamp:
    >Tue Dec 14 17:28:12 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:28:25 2021
- render:
    >function render(window)
    >  window:clear()
    >  -- draw stuff to screen here
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >    print('\n')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:28:45 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >    print('\n')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:28:59 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >    print('\n')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:29:01 2021
- __teliva_timestamp:
    >Tue Dec 14 17:29:11 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- cursor:
    >cursor = string.len(prose)
  __teliva_timestamp:
    >Tue Dec 14 17:29:27 2021
- cursor:
    >cursor = 0
  __teliva_timestamp:
    >Tue Dec 14 17:29:51 2021
- cursor:
    >cursor = 0
  __teliva_timestamp:
    >Tue Dec 14 17:29:58 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >    print('\n')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:52:23 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >--?     print('\n')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:52:49 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >--?     print('\n')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:53:04 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:53:11 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  for _, toot in ipairs(toots) do
    >    print(string.format('=== %d\n', string.len(toot)))
    >    print(toot)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 17:58:27 2021
- cursor:
    >cursor = 0
  __teliva_timestamp:
    >Tue Dec 14 17:58:32 2021
- __teliva_timestamp:
    >Tue Dec 14 17:58:43 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 17:58:49 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text('\n\n===\n\n', pos, cursor)
    >    pos = render_text(toot, pos, cursor)
    >    
    >    for i=1,string.len(toot) do
    >      local c = toot[i]
    >      if pos == cursor then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(c)
    >        window:attroff(curses.A_REVERSE)
    >      else
    >        window:addch(c)
    >      end
    >    end
    >
    >
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 18:03:35 2021
- __teliva_timestamp:
    >Tue Dec 14 18:04:02 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text('\n\n===\n\n', pos, cursor)
    >    pos = render_text(toot, pos, cursor)
    >    
    >    for i=1,string.len(toot) do
    >      local c = toot[i]
    >      if pos == cursor then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(c)
    >        window:attroff(curses.A_REVERSE)
    >      else
    >        window:addch(c)
    >      end
    >    end
    >
    >
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 18:08:53 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text('\n\n===\n\n', pos, cursor)
    >    pos = render_text(toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 18:16:46 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text('\n\n===\n\n', pos, cursor)
    >    pos = render_text(toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 18:17:53 2021
- __teliva_timestamp:
    >Tue Dec 14 18:18:06 2021
  render_text: 
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text('\n\n===\n\n', pos, cursor)
    >    pos = render_text(toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 18:18:09 2021
- __teliva_timestamp:
    >Tue Dec 14 19:04:22 2021
  render_text:
    >
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text('\n\n===\n\n', pos, cursor)
    >    pos = render_text(toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:04:45 2021
- __teliva_timestamp:
    >Tue Dec 14 19:05:34 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  for i=1,string.len(s) do
    >    window:addch(s[i])
    >  end
    >end
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    pos = render_text(window, toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:05:49 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    pos = render_text(window, toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:15:33 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    pos = render_text(window, toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:15:51 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    pos = render_text(window, toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:16:57 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    pos = render_text(window, toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:17:02 2021
- __teliva_timestamp:
    >Tue Dec 14 19:18:15 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  for i=1,string.len(s) do
    >    window:addch(sub(s, i, i))
    >  end
    >end
- __teliva_timestamp:
    >Tue Dec 14 19:18:23 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  for i=1,string.len(s) do
    >    window:addch(s:sub(i, i))
    >  end
    >end
- __teliva_timestamp:
    >Tue Dec 14 19:18:43 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  for i=1,string.len(s) do
    >    window:addch(s:sub(i, i))
    >  end
    >end
- __teliva_timestamp:
    >Tue Dec 14 19:18:45 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  for i=1,string.len(s) do
    >    window:addch(s:sub(i, i))
    >  end
    >end
- __teliva_timestamp:
    >Tue Dec 14 19:18:51 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  for i=1,string.len(s) do
    >    window:addch(s:sub(i, i))
    >  end
    >end
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for _, toot in ipairs(toots) do
    >    pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    pos = render_text(window, toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:21:42 2021
- __teliva_timestamp:
    >Tue Dec 14 19:24:22 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  for i=1,string.len(s) do
    >    window:addch(s[i])
    >  end
    >end
- __teliva_timestamp:
    >Tue Dec 14 19:38:16 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(s[i])
    >      window:attroff(curses.A_REVERSE)
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Tue Dec 14 19:38:25 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(s[i])
    >      window:attroff(curses.A_REVERSE)
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Tue Dec 14 19:39:04 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 19:39:21 2021
- cursor:
    >cursor = 21
  __teliva_timestamp:
    >Tue Dec 14 19:39:47 2021
- cursor:
    >cursor = 20
  __teliva_timestamp:
    >Tue Dec 14 19:39:52 2021
- cursor:
    >cursor = 21
  __teliva_timestamp:
    >Tue Dec 14 19:39:57 2021
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 19:40:21 2021
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 19:40:26 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:41:24 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:42:11 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:42:23 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  prose:insert(key, cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:42:57 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  prose:insert(key, cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:43:33 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  prose:insert(key, cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:43:36 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:44:48 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  prose = prose:insert(key, cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:44:57 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  prose = prose:insert(string.char(key), cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:45:15 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    cursor = cursor-1
    >  end
    >  prose = prose:insert(string.char(key), cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:47:04 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    cursor = cursor-1
    >    return
    >  end
    >  prose = prose:insert(string.char(key), cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:47:22 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    cursor = cursor-1
    >    return
    >  end
    >  prose = prose:insert(string.char(key), cursor-1)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:47:37 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    cursor = cursor-1
    >    return
    >  end
    >  prose = prose:insert(string.char(key), cursor)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:47:49 2021
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 19:47:52 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:47:58 2021
- cursor:
    >cursor = 13
  __teliva_timestamp:
    >Tue Dec 14 19:48:06 2021
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 19:48:18 2021
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 19:48:27 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    cursor = cursor-1
    >    return
    >  end
    >  prose = prose:insert(string.char(key), cursor-1)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:48:33 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >--?   if key == curses.KEY_RIGHT then
    >--?     cursor = cursor+1
    >  prose = prose:insert(string.char(key), cursor-1)
    >  cursor = cursor+1
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:49:32 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >--?   if key == curses.KEY_RIGHT then
    >--?     cursor = cursor+1
    >  if string.find(key, '%C') then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:53:24 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >--?   if key == curses.KEY_RIGHT then
    >--?     cursor = cursor+1
    >  if string.find(key, '%l') then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:53:40 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >--?   if key == curses.KEY_RIGHT then
    >--?     cursor = cursor+1
    >  if string.find(key, '%L') then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:53:49 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >--?   if key == curses.KEY_RIGHT then
    >--?     cursor = cursor+1
    >  local c = string.char(key)
    >  if string.find(c, '%l') then
    >    prose = prose:insert(c, cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:54:41 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >--?   if key == curses.KEY_RIGHT then
    >--?     cursor = cursor+1
    >  if string.printable(key) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:55:48 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >--?   if key == curses.KEY_RIGHT then
    >--?     cursor = cursor+1
    >  if key >= 32 and key < 127 then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:57:37 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >    return
    >  end
    >  if key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  end
    >  if key >= 32 and key < 127 then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:58:09 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      prose = prose:remove(cursor)
    >      cursor = cursor-1
    >    end
    >  elseif key >= 32 and key < 127 then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:59:53 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      prose = prose:remove(cursor)
    >      cursor = cursor-1
    >    end
    >  elseif key >= 32 and key < 127 then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 19:59:55 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key >= 32 and key < 127 then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 20:10:44 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Tue Dec 14 20:11:36 2021
  __teliva_note: 
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(trim(toot)))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 20:13:17 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '===')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(trim(toot)))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Tue Dec 14 20:14:01 2021
- __teliva_timestamp:
    >Tue Dec 14 20:14:17 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- cursor:
    >cursor = 14
  __teliva_timestamp:
    >Tue Dec 14 20:14:23 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Thu Dec 16 03:13:19 2021
- __teliva_undo: 108
  __teliva_timestamp:
    >Thu Dec 16 03:13:35 2021
- __teliva_timestamp:
    >Fri Dec 17 11:41:20 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  local isreverse = false
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:addch(s[i])
    >        window:attron(curses.A_REVERSE)
    >        isreverse = true
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >      if isreverse then
    >        window:attroff(curses.A_REVERSE)
    >        isreverse = false
    >      end
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:42:50 2021
  render_text:
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:45:15 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:45:27 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:45:38 2021
  prose:
    >prose = 'abc\n\n===\n\ndef\n\n'
- __teliva_timestamp:
    >Fri Dec 17 11:45:51 2021
  prose:
    >prose = 'abc\na\n===\n\ndef\n\n'
- __teliva_timestamp:
    >Fri Dec 17 11:46:02 2021
  prose:
    >prose = 'abc\na\n\n===\n\ndef\n\n'
- __teliva_timestamp:
    >Fri Dec 17 11:46:12 2021
  prose:
    >prose = 'abc\n\n===\n\ndef\n\n'
- __teliva_timestamp:
    >Fri Dec 17 11:46:20 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- __teliva_timestamp:
    >Fri Dec 17 11:46:26 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- __teliva_timestamp:
    >Fri Dec 17 11:46:28 2021
  prose:
    >prose = 'abc\n\n===\n\ndef'
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:46:40 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:46:47 2021
- __teliva_timestamp:
    >Fri Dec 17 11:47:27 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  window:mvaddstr(debugy, 60, newpos)
    >  return newpos
    >end
- debugy:
    >debugy = 5
  __teliva_timestamp:
    >Fri Dec 17 11:47:35 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:47:40 2021
- __teliva_timestamp:
    >Fri Dec 17 11:48:26 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  window:mvaddstr(debugy, 60, newpos)
    >  debugy = debugy+1
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:49:32 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, newpos)
    >  debugy = debugy+1
    >  window:setyx(oldy, oldx)
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:49:48 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, newpos)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:50:39 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, newpos)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >  return newpos
    >end
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:50:50 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:51:01 2021
- __teliva_timestamp:
    >Fri Dec 17 11:54:27 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      window:mvaddstr('cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, newpos)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:54:46 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      window:mvaddstr(debugy, 60, 'cursor: '..tostring(cursor))
    >      debugy = debugy+1
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, newpos)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:55:07 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      window:mvaddstr(debugy, 60, 'cursor: '..tostring(cursor))
    >      debugy = debugy+1
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, newpos)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >  return newpos
    >end
- dbg:
    >function dbg(window, s)
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, s)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:56:49 2021
- dbg:
    >function dbg(window, s)
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, s)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:56:55 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 11:57:00 2021
- __teliva_timestamp:
    >Fri Dec 17 11:57:36 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg('cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(newpos)
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:57:47 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, newpos)
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 11:58:58 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, 'start: '..tostring(newpos))
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, newpos)
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:00:48 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local start = pos
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, tostring(start)..'..'..tostring(newpos))
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:00:58 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local start = pos
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, tostring(start)..'..'..tostring(newpos))
    >  return newpos
    >end
- render:
    >?function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:01:11 2021
- render:
    >?function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:01:22 2021
- render:
    >?function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:02:12 2021
- main:
    >function main()
    >  init_colors()
    >
    >  while true do
    >    render(window)
    >    update(window)
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:03:09 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:03:47 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:04:25 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:04:27 2021
- __teliva_timestamp:
    >Fri Dec 17 12:04:47 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local start = pos
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        foo()
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, tostring(start)..'..'..tostring(newpos))
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:05:00 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local start = pos
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, tostring(start)..'..'..tostring(newpos))
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:05:26 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local start = pos
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, tostring(start)..'..'..tostring(newpos))
    >  return newpos
    >end
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:06:43 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch(' ')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:06:48 2021
- __teliva_timestamp:
    >Fri Dec 17 12:08:03 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local start = pos
    >  local newpos = pos
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  dbg(window, tostring(start)..'..'..tostring(newpos))
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:08:45 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg('--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:08:53 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:14:26 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor on newline
    >--   cursor on newline before '===' delimiter
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >    if pos == cursor then
    >      window:attron(curses.A_REVERSE)
    >      window:addch('X')
    >      window:attroff(curses.A_REVERSE)
    >    end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:15:38 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:20:00 2021
- render:
    >function render(window)
    >  window:clear()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:21:11 2021
- __teliva_timestamp:
    >Fri Dec 17 12:23:09 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:26:12 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:26:19 2021
  render_text:
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >  render_text(window, prose, 1, cursor)
    >end
    >
    >function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:27:12 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >  render_text(window, prose, 1, cursor)
    >end
    >
    >function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:27:33 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >  render_text(window, prose, 1, cursor)
    >  curses.refresh()
    >end
    >
    >function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:27:48 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >  render_text(window, prose, 1, cursor)
    >  curses.refresh()
    >end
    >
    >function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 12:36:01 2021
- __teliva_timestamp:
    >Fri Dec 17 12:40:44 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 12:41:01 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >  render_text(window, prose, 1, cursor)
    >  curses.refresh()
    >end
    >
    >function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 13:27:57 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >--? 
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:16:58 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >--? 
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:17:33 2021
- __teliva_timestamp:
    >Fri Dec 17 15:18:03 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        if i > 1 then
    >          window:attron(curses.A_REVERSE)
    >          window:addch(' ')
    >          window:attroff(curses.A_REVERSE)
    >          window:addch(s[i])
    >        end
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:18:45 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >--?         if i > 1 then
    >          window:attron(curses.A_REVERSE)
    >          window:addch(' ')
    >          window:attroff(curses.A_REVERSE)
    >          window:addch(s[i])
    >--?         end
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:19:23 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:19:54 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        if i > 1 then
    >          window:attron(curses.A_REVERSE)
    >          window:addch(' ')
    >          window:attroff(curses.A_REVERSE)
    >        end
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:20:30 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:31:21 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >  render_text(window, prose, 1, cursor)
    >  curses.refresh()
    >end
    >
    >function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:31:29 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:31:53 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:32:20 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:32:39 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >--?     print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:33:00 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >    print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:33:24 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >--?     print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:33:39 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_text(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >--?     print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:34:58 2021
- __teliva_timestamp:
    >Fri Dec 17 15:40:42 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:41:59 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:42:59 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:42:59 2021
  render_delimiter:
    >function render_delimiter(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor and i ~= 1 and i ~= string.len(s) then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_delimiter(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >--?     print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:44:16 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_delimiter(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >--?     print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:44:47 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_delimiter(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >--?     print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:45:19 2021
- render_delimiter:
    >function render_delimiter(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor and i ~= 1 then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:45:38 2021
- render_delimiter:
    >function render_delimiter(window, s, pos, cursor)
    >  local newpos = pos
    >  dbg(window, '--')
    >  for i=1,string.len(s) do
    >    dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor and i ~= 1 then
    >      dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:46:19 2021
- render_delimiter:
    >function render_delimiter(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '==')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor and i ~= 1 then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:46:42 2021
- render_delimiter:
    >function render_delimiter(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '==')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor and i ~= 1 then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  return newpos
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:46:51 2021
- __teliva_timestamp:
    >Fri Dec 17 15:47:06 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '===' delimiter
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 15:48:54 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:49:18 2021
- __teliva_timestamp:
    >Fri Dec 17 15:49:28 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:50:21 2021
- cursor_down:
    >function cursor_down(prose, cursor)
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:50:45 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:51:21 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:54:31 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 15:54:45 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx > 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 16:02:03 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx > 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 16:02:13 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx > 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 16:02:17 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:02:27 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:02:45 2021
- skip_past_newline:
    >function skip_past_newline(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if string[result] == '\n' then
    >      return result+1
    >    end
    >    result = result+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:06:35 2021
- skip_past_newline:
    >function skip_past_newline(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if string[result] == '\n' then
    >      return result+1
    >    end
    >    result = result+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:06:45 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr, newidx)
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:07:07 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), newidx)
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:07:25 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), newidx)
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:07:37 2021
- dbg:
    >function dbg(window, s)
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, s)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:07:41 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(newidx))
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:07:50 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(newidx))
    >  getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:08:08 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:08:19 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(idx)
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:08:53 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:09:04 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:10:55 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:11:13 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx > 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 16:11:19 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 16:12:55 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 16:13:43 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:16:03 2021
- skip_past_newline:
    >function skip_past_newline(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:16:21 2021
- skip_past_newline:
    >function skip_past_newline(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:17:02 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:17:08 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >--?   dbg(curses.stdscr(), tostring(idx))
    >--?   dbg(curses.stdscr(), tostring(colidx))
    >--?   dbg(curses.stdscr(), tostring(newidx))
    >--?   curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:17:42 2021
- cursor_down:
    >function cursor_down(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_past_newline(s, idx)
    >--?   dbg(curses.stdscr(), tostring(idx))
    >--?   dbg(curses.stdscr(), tostring(colidx))
    >--?   dbg(curses.stdscr(), tostring(newidx))
    >--?   curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:18:34 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >--?   dbg(curses.stdscr(), tostring(idx))
    >--?   dbg(curses.stdscr(), tostring(colidx))
    >--?   dbg(curses.stdscr(), tostring(newidx))
    >--?   curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:18:34 2021
- __teliva_timestamp:
    >Fri Dec 17 16:17:02 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result-1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 16:22:50 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result-1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 16:23:04 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result-1
    >  end
    >end
- cursor_up:
    >function cursor_up(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >--?   dbg(curses.stdscr(), tostring(idx))
    >--?   dbg(curses.stdscr(), tostring(colidx))
    >--?   dbg(curses.stdscr(), tostring(newidx))
    >--?   curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:23:08 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_UP then
    >    cursor = cursor_up(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:23:30 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_UP then
    >    cursor = cursor_up(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:23:43 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:23:56 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  while true do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:24:16 2021
- __teliva_timestamp:
    >Fri Dec 17 16:24:34 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 16:24:55 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:27:40 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:28:00 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  newidx = newidx+1
    >  dbg('aaa')
    >  while newidx < string.len(s) do
    >    dbg('iii')
    >    dbg(newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:28:22 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  curses.getch()
    >  newidx = newidx+1
    >  dbg('aaa')
    >  while newidx < string.len(s) do
    >    dbg('iii')
    >    dbg(newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:28:28 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_UP then
    >    cursor = cursor_up(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:28:42 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  dbg('aaa')
    >  while newidx < string.len(s) do
    >    dbg('iii')
    >    dbg(newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  getch()
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:28:59 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  dbg('aaa')
    >  while newidx < string.len(s) do
    >    dbg(curses.stdscr(), 'iii')
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  curses.getch()
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:29:28 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  dbg(window, 'aaa')
    >  while newidx < string.len(s) do
    >    dbg(curses.stdscr(), 'iii')
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  curses.getch()
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:29:35 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  curses.getch()
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:29:46 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:30:06 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 16:32:09 2021
- skip_past_newline:
    >function skip_past_newline(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 19:38:48 2021
- skip_past_newline:
    >function skip_past_newline(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 19:38:51 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:39:07 2021
- __teliva_timestamp:
    >Fri Dec 17 19:41:05 2021
  check_eq:
    >function check_eq(x, msg)
    >  if x then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:41:09 2021
  check_eq:
    >function check_eq(x, msg)
    >  if x then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >  end
    >end
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'F - col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:42:48 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 2, 'F - col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:42:55 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 2, 'F - col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:43:03 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 2, 'F - col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:43:16 2021
- skip_past_newline:
    >function skip_past_newline(s, idx)
    >  local result = idx
    >  while true do
    >    if result >= string.len(s) then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 19:47:36 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 2, 'F - col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:47:55 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 2, 'F - col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:48:05 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 2, 'F - col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:48:21 2021
- __teliva_timestamp:
    >Fri Dec 17 19:49:26 2021
  check_eq:
    >function check_eq(x, msg)
    >  if x then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:49:31 2021
  check_eq:
    >function check_eq(x, msg)
    >  if x then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:49:52 2021
  check_eq:
    >function check_eq(x, msg)
    >  print('AAAA')
    >  curses.getch()
    >  if x then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:50:04 2021
  check_eq:
    >function check_eq(x, msg)
    >  print('AAAA')
    >  curses.getch()
    >  if x then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:50:21 2021
  check_eq:
    >function check_eq(x, expected, msg)
    >  print('AAAA')
    >  curses.getch()
    >  if x then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:50:59 2021
  check_eq:
    >function check_eq(x, expected, msg)
    >  print('AAAA')
    >  curses.getch()
    >  if x == expected then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    print('  expected '..tostring(expected)..' but got '..x)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:51:08 2021
  check_eq:
    >function check_eq(x, expected, msg)
    >  if x == expected then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    print('  expected '..tostring(expected)..' but got '..x)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 19:51:32 2021
  check_eq:
    >function check_eq(x, expected, msg)
    >  if x == expected then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    print('  expected '..tostring(expected)..' but got '..x)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >    if teliva_first_failure == nil then
    >      teliva_first_failure = msg
    >    end
    >  end
    >end
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:52:08 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:53:33 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:53:43 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:55:03 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:55:58 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:57:14 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:57:42 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:58:21 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',             4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:58:34 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 19:59:22 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 20:04:43 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 20:04:51 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 20:05:21 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 20:05:38 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 20:11:07 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")'
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 20:11:26 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")'
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 20:12:28 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")'
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:24:23 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")'
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:24:40 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")'
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:29:27 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")'
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:29:42 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")'
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:29:44 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:29:49 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 2), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:31:06 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:33:29 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:35:11 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 4, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:35:27 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:35:35 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:35:39 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 4, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:37:58 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:46:47 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >  check_eq(col_within_line('abc\ndef', 4), 4, 'col_within_line(..., newline)')
    >  check_eq(col_within_line('abc\ndef', 5), 1, 'col_within_line(..., after newline)')
    >end
    >-- f("abc\ndef", 0) == error
    >-- f("abc\ndef", 1) == 1
    >-- f("abc\ndef", 4) == 4
    >-- f("abc\ndef", 3) == 3
    >-- f("abc\ndef", 5) == 1
  __teliva_timestamp:
    >Fri Dec 17 21:48:41 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >  check_eq(col_within_line('abc\ndef', 4), 4, 'col_within_line(..., newline)')
    >  check_eq(col_within_line('abc\ndef', 5), 1, 'col_within_line(..., after newline)')
    >end
  __teliva_timestamp:
    >Fri Dec 17 21:48:56 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >  check_eq(col_within_line('abc\ndef', 4), 4, 'col_within_line(..., newline)')
    >  check_eq(col_within_line('abc\ndef', 5), 1, 'col_within_line(..., after newline)')
    >end
  __teliva_timestamp:
    >Fri Dec 17 21:49:01 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >  check_eq(col_within_line('abc\ndef', 4), 4, 'col_within_line(..., newline)')
    >  check_eq(col_within_line('abc\ndef', 5), 1, 'col_within_line(..., after newline)')
    >end
  __teliva_timestamp:
    >Fri Dec 17 21:55:29 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >  check_eq(col_within_line('abc\ndef', 4), 4, 'col_within_line(..., newline)')
    >  check_eq(col_within_line('abc\ndef', 5), 1, 'col_within_line(..., after newline)')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:25:28 2021
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >  check_eq(col_within_line('abc\ndef', 4), 4, 'col_within_line(..., newline)')
    >  check_eq(col_within_line('abc\ndef', 5), 1, 'col_within_line(..., after newline)')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:25:50 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:27:38 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:29:33 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 2, 'cursor_up: top line')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:29:42 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:29:47 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:30:58 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:31:47 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:32:15 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:32:27 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:32:58 2021
- __teliva_timestamp:
    >Fri Dec 17 22:34:11 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: 1, 1')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:39:38 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:40:19 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:40:28 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:40:33 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >end
- col_within_line:
    >function col_within_line(s, idx)
    >  if idx <= 1 then
    >    return idx
    >  end
    >  idx = idx-1
    >  local result = 1
    >  while idx >= 1 do
    >    if s[idx] == '\n' then break end
    >    idx = idx-1
    >    result=result+1
    >  end
    >  return result
    >end
    >
    >function test_col_within_line()
    >  check_eq(col_within_line('',         4), 4, 'col_within_line("")')
    >  check_eq(col_within_line('abc\ndef', 1), 1, 'col_within_line(..., 1)')
    >  check_eq(col_within_line('abc\ndef', 3), 3, 'col_within_line(..., -1)')
    >  check_eq(col_within_line('abc\ndef', 4), 4, 'col_within_line(..., newline)')
    >  check_eq(col_within_line('abc\ndef', 5), 1, 'col_within_line(..., after newline)')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:40:43 2021
- __teliva_timestamp:
    >Fri Dec 17 22:41:12 2021
  check_eq:
    >function check_eq(x, expected, msg)
    >  if x == expected then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    print('  expected '..tostring(expected)..' but got '..x)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >    if teliva_first_failure == nil then
    >      teliva_first_failure = msg
    >    end
    >  end
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:41:24 2021
  check_eq:
    >function check_eq(x, expected, msg)
    >  if x == expected then
    >    io.write('.')
    >  else
    >    print('F - '..msg)
    >    print('  expected '..tostring(expected)..' but got '..x)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >    if teliva_first_failure == nil then
    >      teliva_first_failure = msg
    >    end
    >  end
    >end
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:41:31 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:41:34 2021
- __teliva_timestamp:
    >Fri Dec 17 22:42:11 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:42:19 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:42:22 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:42:39 2021
- __teliva_timestamp:
    >Fri Dec 17 22:43:15 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:44:25 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result=result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:44:46 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, result)
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:45:03 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:45:14 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:45:53 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:46:01 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:46:30 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:47:50 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:48:27 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 2, 'start of previous line: second line, mid char')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:48:54 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:49:58 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 5, 'start of previous line: to empty line')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:50:49 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 5, 'start of previous line: to empty line')
    >  check_eq(skip_to_start_of_previous_line('abc\nd\nghi', 8), 5, 'start of previous line: to shorter line')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:51:19 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 5, 'start of previous line: to empty line')
    >  check_eq(skip_to_start_of_previous_line('abc\nd\nghi', 8), 5, 'start of previous line: to shorter line')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:52:38 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 9), 1, 'start of previous line: final line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 10), 1, 'start of previous line: final line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 11), 1, 'start of previous line: final line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 12), 1, 'start of previous line: end of file')
    >
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 5, 'start of previous line: to empty line')
    >  check_eq(skip_to_start_of_previous_line('abc\nd\nghi', 8), 5, 'start of previous line: to shorter line')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:52:57 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 9), 4, 'start of previous line: final line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 10), 4, 'start of previous line: final line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 11), 4, 'start of previous line: final line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 12), 4, 'start of previous line: end of file')
    >
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 5, 'start of previous line: to empty line')
    >  check_eq(skip_to_start_of_previous_line('abc\nd\nghi', 8), 5, 'start of previous line: to shorter line')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:53:31 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 9), 4, 'start of previous line: final line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 10), 4, 'start of previous line: final line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 11), 4, 'start of previous line: final line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 12), 4, 'start of previous line: end of file')
    >
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 4, 'start of previous line: to empty line')
    >  check_eq(skip_to_start_of_previous_line('abc\nd\nghi', 8), 4, 'start of previous line: to shorter line')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:53:58 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 9), 5, 'start of previous line: final line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 10), 5, 'start of previous line: final line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 11), 5, 'start of previous line: final line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 12), 5, 'start of previous line: end of file')
    >
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 5, 'start of previous line: to empty line')
    >  check_eq(skip_to_start_of_previous_line('abc\nd\nghi', 8), 5, 'start of previous line: to shorter line')
    >end
- __teliva_timestamp:
    >Fri Dec 17 22:54:12 2021
  skip_to_start_of_previous_line:
    >function skip_to_start_of_previous_line(s, idx)
    >  local result = idx
    >  -- skip to newline
    >  if idx == 1 then return 1 end
    >  result = result-1  -- just in case we start out on a newline
    >  while true do
    >    if result <= 1 then
    >      return idx
    >    end
    >    if s[result] == '\n' then
    >      result = result-1
    >      break
    >    end
    >    result = result-1
    >  end
    >  dbg(window, 'skip: '..tostring(result))
    >  while true do
    >    if result <= 1 then
    >      return result
    >    end
    >    if s[result] == '\n' then
    >      return result+1
    >    end
    >    result = result-1
    >  end
    >end
    >
    >function test_skip_to_start_of_previous_line()
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 1), 1, 'start of previous line: first line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 2), 2, 'start of previous line: first line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 3), 3, 'start of previous line: first line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 4), 4, 'start of previous line: first line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 5), 1, 'start of previous line: second line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 6), 1, 'start of previous line: second line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 7), 1, 'start of previous line: second line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 8), 1, 'start of previous line: second line, newline')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 9), 5, 'start of previous line: final line, first char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 10), 5, 'start of previous line: final line, mid char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 11), 5, 'start of previous line: final line, final char')
    >  check_eq(skip_to_start_of_previous_line('abc\ndef\nghi', 12), 5, 'start of previous line: end of file')
    >
    >  check_eq(skip_to_start_of_previous_line('abc\n\nghi', 7), 5, 'start of previous line: to empty line')
    >  check_eq(skip_to_start_of_previous_line('abc\nd\nghi', 8), 5, 'start of previous line: to shorter line')
    >end
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:54:58 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), tostring(idx))
    >  dbg(curses.stdscr(), tostring(colidx))
    >  dbg(curses.stdscr(), tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:55:17 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'colidx'..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx'..tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:55:43 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'colidx'..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx'..tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:55:59 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'col '..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx '..tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:56:18 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'col '..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx '..tostring(newidx))
    >  newidx = newidx+1
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    dbg(curses.stdscr(), '  col '..tostring(newcolidx))
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:56:54 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'col '..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx '..tostring(newidx))
    >  while newidx < string.len(s) do
    >    dbg(window, newidx)
    >    if s[newidx] == '\n' then break end
    >    local newcolidx = col_within_line(s, newidx)
    >    dbg(curses.stdscr(), '  col '..tostring(newcolidx))
    >    if newcolidx == colidx then break end
    >    newidx = newidx+1
    >  end
    >  dbg(window, '=> '..tostring(newidx))
    >  curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:57:12 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >--?   dbg(curses.stdscr(), 'idx '..tostring(idx))
    >--?   dbg(curses.stdscr(), 'col '..tostring(colidx))
    >--?   dbg(curses.stdscr(), 'prev line start idx '..tostring(newidx))
    >  for i=1,colidx do
    >    if newidx >= string.len(s) then break end
    >    if s[newidx] == '\n' then break end
    >    newidx = newidx+1
    >  end
    >--?   while newidx < string.len(s) do
    >--?     dbg(window, newidx)
    >--?     if s[newidx] == '\n' then break end
    >--?     local newcolidx = col_within_line(s, newidx)
    >--?     dbg(curses.stdscr(), '  col '..tostring(newcolidx))
    >--?     if newcolidx == colidx then break end
    >--?     newidx = newidx+1
    >--?   end
    >--?   dbg(window, '=> '..tostring(newidx))
    >--?   curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:59:23 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'col '..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx '..tostring(newidx))
    >  for i=1,colidx do
    >    if newidx >= string.len(s) then break end
    >    if s[newidx] == '\n' then break end
    >    newidx = newidx+1
    >  end
    >--?   while newidx < string.len(s) do
    >--?     dbg(window, newidx)
    >--?     if s[newidx] == '\n' then break end
    >--?     local newcolidx = col_within_line(s, newidx)
    >--?     dbg(curses.stdscr(), '  col '..tostring(newcolidx))
    >--?     if newcolidx == colidx then break end
    >--?     newidx = newidx+1
    >--?   end
    >--?   dbg(window, '=> '..tostring(newidx))
    >--?   curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 22:59:47 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'col '..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx '..tostring(newidx))
    >  for i=1,colidx do
    >    if newidx >= string.len(s) then break end
    >    if s[newidx] == '\n' then break end
    >    newidx = newidx+1
    >  end
    >--?   while newidx < string.len(s) do
    >--?     dbg(window, newidx)
    >--?     if s[newidx] == '\n' then break end
    >--?     local newcolidx = col_within_line(s, newidx)
    >--?     dbg(curses.stdscr(), '  col '..tostring(newcolidx))
    >--?     if newcolidx == colidx then break end
    >--?     newidx = newidx+1
    >--?   end
    >--?   dbg(window, '=> '..tostring(newidx))
    >--?   curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 23:00:02 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  dbg(curses.stdscr(), 'idx '..tostring(idx))
    >  dbg(curses.stdscr(), 'col '..tostring(colidx))
    >  dbg(curses.stdscr(), 'prev line start idx '..tostring(newidx))
    >  for i=2,colidx do  -- we're already starting at col 1
    >    if newidx >= string.len(s) then break end
    >    if s[newidx] == '\n' then break end
    >    newidx = newidx+1
    >  end
    >--?   while newidx < string.len(s) do
    >--?     dbg(window, newidx)
    >--?     if s[newidx] == '\n' then break end
    >--?     local newcolidx = col_within_line(s, newidx)
    >--?     dbg(curses.stdscr(), '  col '..tostring(newcolidx))
    >--?     if newcolidx == colidx then break end
    >--?     newidx = newidx+1
    >--?   end
    >--?   dbg(window, '=> '..tostring(newidx))
    >--?   curses.getch()
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 23:00:36 2021
- cursor_up:
    >function cursor_up(s, idx)
    >  if idx <= 1 then return idx end
    >  -- check column within current line, then go to start of previous line, then count off columns there
    >  local colidx = col_within_line(s, idx)
    >  local newidx = skip_to_start_of_previous_line(s, idx)
    >  if newidx == idx then return idx end
    >  if s[newidx] == '\n' then return newidx end
    >  for i=2,colidx do  -- we're already starting at col 1
    >    if newidx >= string.len(s) then break end
    >    if s[newidx] == '\n' then break end
    >    newidx = newidx+1
    >  end
    >  return newidx
    >end
    >
    >function test_cursor_up()
    >  check_eq(cursor_up('abc\ndef', 1), 1, 'cursor_up: top line first char')
    >  check_eq(cursor_up('abc\ndef', 2), 2, 'cursor_up: top line mid char')
    >  check_eq(cursor_up('abc\ndef', 3), 3, 'cursor_up: top line final char')
    >  check_eq(cursor_up('abc\ndef', 4), 4, 'cursor_up: top line end')
    >  check_eq(cursor_up('abc\ndef', 5), 1, 'cursor_up: second line first char')
    >end
  __teliva_timestamp:
    >Fri Dec 17 23:02:05 2021
- render:
    >function render(window)
    >  window:clear()
    >  debugy = 5
    >--?   render_text(window, prose, 1, cursor)
    >--?   curses.refresh()
    >--? end
    >
    >--? function unused()
    >  local toots = split(prose, '\n\n===\n\n')
    >  pos = 1
    >  debugy = 5
    >  for i, toot in ipairs(toots) do
    >    if i > 1 then
    >      pos = render_delimiter(window, '\n\n===\n\n', pos, cursor)
    >    end
    >    pos = render_text(window, toot, pos, cursor)
    >--?     if pos == cursor then
    >--?       window:attron(curses.A_REVERSE)
    >--?       window:addch(' ')
    >--?       window:attroff(curses.A_REVERSE)
    >--?     end
    >    print('')
    >    window:attron(curses.A_BOLD)
    >    window:addstr(string.len(toot))
    >    window:attroff(curses.A_BOLD)
    >--?     print('')
    >  end
    >  curses.refresh()
    >end
  __teliva_timestamp:
    >Fri Dec 17 23:04:57 2021
- __teliva_timestamp:
    >Fri Dec 17 23:05:47 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(string.char(s[i]))
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:05:56 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(string.byte(s[i]))
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:06:09 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch('a'..s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:06:33 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(string.char(s[i]))
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:06:44 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(string.char('a'..s[i]))
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:06:58 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i]))
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:07:08 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(string.char(s[i]))
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:07:21 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addch(tostring(s[i]))
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:07:39 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      dbg(window, type(s[i]))
    >      window:addch(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:08:03 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addch(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addch(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      dbg(window, type(s[i]))
    >      window:addstr(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:08:23 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addstr(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addstr(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addstr(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- __teliva_timestamp:
    >Fri Dec 17 23:08:32 2021
  render_text:
    >-- https://gankra.github.io/blah/text-hates-you
    >-- https://lord.io/text-editing-hates-you-too
    >
    >-- manual tests:
    >--   cursor on some character
    >--   cursor on (within) '\n\n===\n\n' delimiter (delimiter is hardcoded; things may break if you change it)
    >--   cursor at end of each line
    >--   render digits
    >
    >-- positions serve two purposes:
    >--   character to index into prose
    >--   cursor-printing
    >
    >-- sequence of stories
    >--   focus on rendering a single piece of text, first get that rock-solid
    >--   split prose into toots, manage transitions between toots in response to cursor movements
    >--   cursor movement: left/right vs up/down
    >
    >-- what is the ideal representation?
    >--   prose + cursor has issues in multi-toot context. when to display cursor?
    >function render_text(window, s, pos, cursor)
    >  local newpos = pos
    >--?   dbg(window, '--')
    >  for i=1,string.len(s) do
    >--?     dbg(window, tostring(newpos)..' '..tostring(string.byte(s[i])))
    >    if newpos == cursor then
    >--?       dbg(window, 'cursor: '..tostring(cursor))
    >      if s[i] == '\n' then
    >        -- newline at cursor = render extra space in reverse video before jumping to new line
    >        window:attron(curses.A_REVERSE)
    >        window:addch(' ')
    >        window:attroff(curses.A_REVERSE)
    >        window:addstr(s[i])
    >      else
    >        -- most characters at cursor = render in reverse video
    >        window:attron(curses.A_REVERSE)
    >        window:addstr(s[i])
    >        window:attroff(curses.A_REVERSE)
    >      end
    >    else
    >      window:addstr(s[i])
    >    end
    >    newpos = newpos+1
    >  end
    >  if newpos == cursor then
    >    window:attron(curses.A_REVERSE)
    >    window:addch(' ')
    >    window:attroff(curses.A_REVERSE)
    >  end
    >  return newpos
    >end
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_UP then
    >    cursor = cursor_up(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 21 then  -- ctrl-u
    >    prose = ''
    >    cursor = 1
    >  end
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 23:12:03 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_UP then
    >    cursor = cursor_up(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 21 then  -- ctrl-u
    >    prose = ''
    >    cursor = 1
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 23:12:07 2021
- update:
    >function update(window)
    >  local key = curses.getch()
    >  if key == curses.KEY_LEFT then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if cursor <= #prose then
    >      cursor = cursor+1
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    cursor = cursor_down(prose, cursor)
    >  elseif key == curses.KEY_UP then
    >    cursor = cursor_up(prose, cursor)
    >  elseif key == curses.KEY_BACKSPACE then
    >    if cursor > 1 then
    >      cursor = cursor-1
    >      prose = prose:remove(cursor)
    >    end
    >  elseif key == 21 then  -- ctrl-u
    >    prose = ''
    >    cursor = 1
    >  elseif key == 10 or (key >= 32 and key < 127) then
    >    prose = prose:insert(string.char(key), cursor-1)
    >    cursor = cursor+1
    >  end
    >end
  __teliva_timestamp:
    >Fri Dec 17 23:12:14 2021
- menu:
    >menu = {}
    >menu['^u'] = 'clear'
  __teliva_timestamp:
    >Fri Dec 17 23:13:04 2021
