# .tlv file generated by https://github.com/akkartik/teliva
# You may edit it if you are careful; however, you may see cryptic errors if you
# violate Teliva's assumptions.
#
# .tlv files are representations of Teliva programs. Teliva programs consist of
# sequences of definitions. Each definition is a table of key/value pairs. Keys
# and values are both strings.
#
# Lines in .tlv files always follow exactly one of the following forms:
# - comment lines at the top of the file starting with '#' at column 0
# - beginnings of definitions starting with '- ' at column 0, followed by a
#   key/value pair
# - key/value pairs consisting of '  ' at column 0, containing either a
#   spaceless value on the same line, or a multi-line value
# - multiline values indented by more than 2 spaces, starting with a '>'
#
# If these constraints are violated, Teliva may unceremoniously crash. Please
# report bugs at http://akkartik.name/contact
- __teliva_timestamp: original
  str_helpers:
    >-- some string helpers from http://lua-users.org/wiki/StringIndexing
    >
    >-- index characters using []
    >getmetatable('').__index = function(str,i)
    >  if type(i) == 'number' then
    >    return string.sub(str,i,i)
    >  else
    >    return string[i]
    >  end
    >end
    >
    >-- ranges using (), selected bytes using {}
    >getmetatable('').__call = function(str,i,j)
    >  if type(i)~='table' then
    >    return string.sub(str,i,j)
    >  else
    >    local t={}
    >    for k,v in ipairs(i) do
    >      t[k]=string.sub(str,v,v)
    >    end
    >    return table.concat(t)
    >  end
    >end
    >
    >-- iterate over an ordered sequence
    >function q(x)
    >  if type(x) == 'string' then
    >    return x:gmatch('.')
    >  else
    >    return ipairs(x)
    >  end
    >end
    >
    >-- insert within string
    >function string.insert(str1, str2, pos)
    >  return str1:sub(1,pos)..str2..str1:sub(pos+1)
    >end
    >
    >function string.remove(s, pos)
    >  return s:sub(1,pos-1)..s:sub(pos+1)
    >end
    >
    >-- TODO: backport utf-8 support from Lua 5.3
- __teliva_timestamp: original
  debugy:
    >debugy = 5
- __teliva_timestamp: original
  dbg:
    >-- helper for debug by print; overlay debug information towards the right
    >-- reset debugy every time you refresh screen
    >function dbg(window, s)
    >  local oldy = 0
    >  local oldx = 0
    >  oldy, oldx = window:getyx()
    >  window:mvaddstr(debugy, 60, s)
    >  debugy = debugy+1
    >  window:mvaddstr(oldy, oldx, '')
    >end
- __teliva_timestamp: original
  check_eq:
    >function check_eq(x, expected, msg)
    >  if x == expected then
    >    curses.addch('.')
    >  else
    >    print('F - '..msg)
    >    print('  expected '..tostring(expected)..' but got '..x)
    >    teliva_num_test_failures = teliva_num_test_failures + 1
    >    -- overlay first test failure on editors
    >    if teliva_first_failure == nil then
    >      teliva_first_failure = msg
    >    end
    >  end
    >end
- __teliva_timestamp: original
  map:
    >-- only for arrays
    >function map(l, f)
    >  result = {}
    >  for _, x in ipairs(l) do
    >    table.insert(result, f(x))
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  reduce:
    >-- only for arrays
    >function reduce(l, f, init)
    >  result = init
    >  for _, x in ipairs(l) do
    >    result = f(result, x)
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  filter:
    >-- only for arrays
    >function filter(l, f)
    >  result = {}
    >  for _, x in ipairs(l) do
    >    if f(x) then
    >      table.insert(result, x)
    >    end
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  find_index:
    >function find_index(arr, x)
    >  for n, y in ipairs(arr) do
    >    if x == y then
    >      return n
    >    end
    >  end
    >end
- __teliva_timestamp: original
  trim:
    >function trim(s)
    >  return s:gsub('^%s*', ''):gsub('%s*$', '')
    >end
- __teliva_timestamp: original
  split:
    >function split(s, d)
    >  result = {}
    >  for match in (s..d):gmatch("(.-)"..d) do
    >    table.insert(result, match);
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  spaces:
    >function spaces(n)
    >  for i=1,n do
    >    curses.addch(' ')
    >  end
    >end
- __teliva_timestamp: original
  window:
    >window = curses.stdscr()
- __teliva_timestamp: original
  menu:
    >-- To show app-specific hotkeys in the menu bar, add hotkey/command
    >-- arrays of strings to the menu array.
    >menu = {}
- __teliva_timestamp: original
  update:
    >function update(window)
    >  local key = curses.getch()
    >  -- process key here
    >end
- __teliva_timestamp: original
  init_colors:
    >function init_colors()
    >  -- light background
    >  curses.init_pair(view_settings.current_zettel_bg, 236, 230)
    >  curses.init_pair(1, 236, 250)
    >  curses.init_pair(2, 236, 252)
    >  -- dark background
    >--?   curses.init_pair(view_settings.current_zettel_bg, 252, 130)
    >--?   curses.init_pair(1, 252, 240)
    >--?   curses.init_pair(2, 252, 242)
    >end
- __teliva_timestamp: original
  main:
    >function main()
    >  init_colors()
    >  current_zettel_id = zettels.root
    >
    >  while true do
    >    render(window)
    >    update(window)
    >  end
    >end
- __teliva_timestamp: original
  depth:
    >function depth(zettel)
    >  local result = 0
    >  while zettel.parent do
    >    result = result+1
    >    zettel = zettel.parent
    >  end
    >  return result
    >end
- __teliva_timestamp: original
  render_zettel:
    >function render_zettel(window, bg, indent, starty, startx, zettel)
    >  window:attrset(curses.color_pair(bg))
    >  for y=0,view_settings.height-1 do
    >    for x=0,view_settings.width-1 do
    >      window:mvaddch(y+starty, x+startx, ' ')
    >    end
    >  end
    >  local y, x = 0, indent+1
    >  for i=1,#zettel.data do
    >    local c = zettel.data[i]
    >    if c == '\n' then
    >      y = y+1
    >      x = indent+1
    >    else
    >      window:mvaddch(y+starty, x+startx, c)
    >      x = x+1
    >      if x >= startx + view_settings.width then
    >        y = y+1
    >        x = indent+1
    >      end
    >    end
    >    if y >= starty + view_settings.height then
    >      break
    >    end
    >  end
    >end
- __teliva_timestamp: original
  current_zettel_id:
    >current_zettel_id = ''
- __teliva_timestamp: original
  view_settings:
    >view_settings = {
    >  -- dimensions for rendering a single zettel; extra text gets truncated
    >  width=50,
    >  height=3,
    >  -- spacing between zettels
    >  hmargin=1,
    >  vmargin=1,
    >  --
    >  indent=2,  -- how children of a zettel are indicated
    >  current_zettel_bg=3,  -- color pair index initialized in init_colors
    >}
- __teliva_timestamp: original
  zettels:
    >zettels = {
    >  root="a",
    >  a={
    >    data="abc\ndef",
    >    child="c",
    >    next="b",
    >  },
    >  b={
    >    data="ghi\njklm",
    >    prev="a",
    >  },
    >  c={
    >    data="c",
    >    parent="a",
    >    next="d",
    >  },
    >  d={
    >    data="d",
    >    parent="a",
    >    prev="c",
    >  }
    >}
- __teliva_timestamp: original
  render_state:
    >-- some information about what's been drawn on screen
    >render_state = {
    >  -- where the current zettel is, in units of zettels
    >  curr_h = 1,
    >  curr_w = 1,
    >  -- what zettel is at each position on screen, in units of zettels
    >  hw2id = {},
    >}
- __teliva_timestamp: original
  update:
    >function update(window)
    >  local key = curses.getch()
    >  local curr = zettels[current_zettel_id]
    >  -- graph-based navigation
    >  if key == string.byte('j') then
    >    if curr.child then
    >      current_zettel_id = curr.child
    >    elseif curr.next then
    >      current_zettel_id = curr.next
    >    elseif curr.parent and zettels[curr.parent].next then
    >      current_zettel_id = zettels[curr.parent].next
    >    end
    >  elseif key == string.byte('k') then
    >    if curr.parent then current_zettel_id = curr.parent end
    >  elseif key == string.byte('h') then
    >    if curr.prev then
    >      current_zettel_id = curr.prev
    >    elseif curr.parent then
    >      current_zettel_id = curr.parent
    >    end
    >  elseif key == string.byte('l') then
    >    if curr.next then
    >      current_zettel_id = curr.next
    >    elseif curr.parent and zettels[curr.parent].next then
    >      current_zettel_id = zettels[curr.parent].next
    >    end
    >  -- screen-based navigation
    >  elseif key == curses.KEY_UP then
    >    if render_state.curr_h > 1 then
    >      current_zettel_id = render_state.wh2id[render_state.curr_w][render_state.curr_h - 1]
    >    end
    >  elseif key == curses.KEY_DOWN then
    >    if render_state.wh2id[render_state.curr_w][render_state.curr_h + 1] then
    >      current_zettel_id = render_state.wh2id[render_state.curr_w][render_state.curr_h + 1]
    >    end
    >  elseif key == curses.KEY_LEFT then
    >    if render_state.curr_w > 1 then
    >      current_zettel_id = render_state.wh2id[render_state.curr_w - 1][render_state.curr_h]
    >    end
    >  elseif key == curses.KEY_RIGHT then
    >    if render_state.wh2id[render_state.curr_w + 1] and render_state.wh2id[render_state.curr_w + 1][render_state.curr_h] then
    >      current_zettel_id = render_state.wh2id[render_state.curr_w + 1][render_state.curr_h]
    >    end
    >  end
    >end
- __teliva_timestamp: original
  render:
    >function render(window)
    >  window:clear()
    >  local lines, cols = window:getmaxyx()
    >  local bg=1
    >  local y, x = 0, 0 -- units of characters (0-based)
    >  local w, h = 1, 1 -- units of zettels (1-based)
    >  -- render zettels depth-first, while tracking relative positions
    >  local done = {}
    >  local inprogress = {zettels.root}
    >  render_state.wh2id = {{}}
    >  while #inprogress > 0 do
    >    local currid = table.remove(inprogress)
    >    if not done[currid] then
    >      done[currid] = true
    >      table.insert(render_state.wh2id[w], currid)
    >      local zettel = zettels[currid]
    >      if currid == current_zettel_id then
    >        render_state.curr_w = w
    >        render_state.curr_h = h
    >      end
    >      local currbg = (currid == current_zettel_id) and view_settings.current_zettel_bg or bg
    >      render_zettel(window, currbg, depth(zettel) * view_settings.indent, y, x, zettel)
    >      if zettel.next then table.insert(inprogress, zettel.next) end
    >      if zettel.child then table.insert(inprogress, zettel.child) end
    >      bg = 3 - bg  -- toggle between color pairs 1 and 2
    >      y = y + view_settings.height + view_settings.vmargin
    >      h = h + 1
    >      if y + view_settings.height > lines then
    >        y = 0
    >        h = 1
    >        x = x + view_settings.width + view_settings.hmargin
    >        w = w + 1
    >        if x + view_settings.width > cols then break end
    >        table.insert(render_state.wh2id, {})
    >      end
    >    end
    >  end
    >  window:mvaddstr(lines-2, 0, '')
    >  for i=1,3 do
    >    window:attrset(curses.color_pair(i%2+1))
    >    window:addstr('')
    >    spaces(view_settings.width-string.len(''))
    >    window:attrset(curses.color_pair(0))
    >    window:addstr(' ')  -- margin
    >  end
    >  window:mvaddstr(lines-1, 0, '? ')
    >  curses.refresh()
    >end
- __teliva_timestamp: original
  view_settings:
    >view_settings = {
    >  -- dimensions for rendering a single zettel; extra text gets truncated
    >  width=50,
    >  height=3,
    >  -- spacing between zettels
    >  hmargin=1,
    >  vmargin=1,
    >  --
    >  indent=2,  -- how children of a zettel are indicated
    >  current_zettel_bg=3,  -- color pair index initialized in init_colors
    >}
